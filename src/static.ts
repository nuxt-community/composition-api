import { ssrRef } from './ssr-ref'
import { Ref, onServerPrefetch, watch, computed } from '@vue/composition-api'

const staticPath = '<%= options.staticPath %>'
const staticCache: Record<string, any> = {}

async function writeFile(key: string) {
  if (process.client || !process.static) return

  const { writeFileSync }: typeof import('fs') = process.client
    ? ''
    : require('fs')
  const { join }: typeof import('path') = process.client ? '' : require('path')

  try {
    writeFileSync(
      join(staticPath, `${key}.json`),
      JSON.stringify(staticCache[key])
    )
  } catch (e) {
    console.log(e)
  }
}
/**
 * You can statically generate expensive functions using `useStatic`. 

  1. If you are generating the whole app (or just prerendering some routes with `nuxt build && nuxt generate --no-build`) the following behaviour will be unlocked:
      * On generate, the result of a `useStatic` call will be saved to a JSON file and copied into the `/dist` directory.
      * On either client and server navigation to a generated page, this JSON will be fetched - and once fetched it will be cached for subsequent navigations.
      * If for whatever reason this JSON doesn't exist, such as if the page *wasn't* pre-generated, the original factory function will be run on client-side.

  2. If the route is not pre-generated (including in dev mode), then:
      * On a hard-reload, the server will run the factory function and inline the result in `nuxtState` - so the client won't rerun the API request.
      * On client navigation, the client will run the factory function.

  In both of these cases, the return result of `useStatic` is a `null` ref that is filled with the result of the factory function or JSON fetch when it resolves.

 * @param factory The async function that will populate the ref this function returns. It receives the param and keyBase (see below) as parameters.
 * @param param A an optional param (such as an ID) to distinguish multiple API fetches using the same factory function.
 * @param keyBase A key that should be unique across your project. If not provided, this will be auto-generated by `nuxt-composition-api`.
 * @example
  ```ts
  import { defineComponent, useContext, useStatic, computed } from 'nuxt-composition-api'
  import axios from 'axios'

  export default defineComponent({
    setup() {
      const { params } = useContext()
      const id = computed(() => params.value.id)
      const post = useStatic(
        id => axios.get(`https://jsonplaceholder.typicode.com/posts/${id}`),
        id,
        'posts'
      )

      return { post }
    },
  })
  ```
 */
export const useStatic = <T>(
  factory: (param: string, key: string) => Promise<T>,
  param: Ref<string> = { value: '' },
  keyBase: string
): Ref<T | null> => {
  const key = computed(() => `${keyBase}-${param.value}`)
  const result = ssrRef<T | null>(null, key.value)

  if (result.value) staticCache[key.value] = result.value

  if (process.client) {
    const onFailure = () =>
      factory(param.value, key.value).then(r => {
        staticCache[key.value] = r
        result.value = r
        return
      })
    watch(key, key => {
      if (key in staticCache) {
        result.value = staticCache[key]
        return
      }
      /* eslint-disable promise/always-return */
      if (!process.static) onFailure()
      else
        fetch(`<%= options.publicPath %>/${key}.json`)
          .then(response => {
            if (!response.ok) throw new Error('Response invalid.')
            return response.json()
          })
          .then(json => {
            staticCache[key] = json
            result.value = json
          })
          .catch(onFailure)
      /* eslint-enable */
    })
  } else {
    if (key.value in staticCache) {
      result.value = staticCache[key.value]
      return result
    }
    onServerPrefetch(async () => {
      result.value = await factory(param.value, key.value)
      staticCache[key.value] = result.value
      writeFile(key.value)
    })
  }

  return result
}
